Q.1) Writing PL/SQL Blocks with basic programming constructs by including following:
 a. Sequential Statements             b. unconstrained loop

-- PL/SQL Block to Calculate Factorial using Unconstrained Loop
DECLARE
-- Declare variables
num NUMBER := 5; -- Change this to the desired number for which you want to calculate the
factorial
factorial NUMBER := 1;
counter NUMBER := 1;
BEGIN
-- Check if the number is negative
IF num < 0 THEN
DBMS_OUTPUT.PUT_LINE('Factorial is not defined for negative numbers.');
ELSE
-- Calculate factorial using an unconstrained loop
LOOP
factorial := factorial * counter;
counter := counter + 1;
-- Exit the loop when the counter reaches the input number
EXIT WHEN counter > num;
END LOOP;
-- Display the result
DBMS_OUTPUT.PUT_LINE('Factorial of ' || num || ' is ' || factorial);
END IF;
END;
/


Q.2) Creating Simple Sequences
Example 1: Creating a Simple Sequence with START WITH, INCREMENT BY, MAXVALUE,
MINVALUE, CYCLE, CACHE, and ORDER.

-- Create a sequence with various clauses
CREATE SEQUENCE my_sequence
START WITH 1
INCREMENT BY 2
MAXVALUE 100
MINVALUE 1
CYCLE CACHE 10 ORDER;
In this example:
• START WITH 1 specifies that the sequence should start with the value 1.
• INCREMENT BY 2 specifies that the sequence should increment by 2 for each next value.
• MAXVALUE 100 specifies the maximum value the sequence can reach (in this case, 100).
• MINVALUE 1 specifies the minimum value for the sequence.
• CYCLE means that the sequence will cycle back to the MINVALUE after reaching the
MAXVALUE.
• CACHE 10 specifies that Oracle should cache 10 sequence numbers for better
performance.
• ORDER ensures that the sequence numbers are generated in order.

Example 2: Creating a Simple Sequence with NOCYCLE and NOCACHE

-- Create a sequence with NOCYCLE and NOCACHE clauses
CREATE SEQUENCE my_sequence_no_cycle_no_cache
START WITH 1000
INCREMENT BY 1
MAXVALUE 9999
NOCYCLE NOCACHE;
In this example, NOCYCLE ensures that the sequence does not cycle back to the MINVALUE
after reaching the MAXVALUE, and NOCACHE specifies that no values are cached.
Creating and Using Sequences for Tables
You can use sequences to generate unique values for columns in tables, such as primary keys.
Here's an example of creating a table with a sequence-generated primary key:
-- Create a table with a sequence-generated primary key
CREATE TABLE employees (employee_id NUMBER PRIMARY KEY,
first_name VARCHAR2(50),
last_name VARCHAR2(50));
-- Create a sequence to generate unique employee IDs
CREATE SEQUENCE employee_id_seq
START WITH 1
INCREMENT BY 1
NOCACHE;
-- Use the sequence to insert data into the table
INSERT INTO employees (employee_id, first_name, last_name)
VALUES (employee_id_seq.NEXTVAL, 'John', 'Doe');
INSERT INTO employees (employee_id, first_name, last_name)
VALUES (employee_id_seq.NEXTVAL, 'Jane', 'Smith');



Q.3) Writing PL/SQL Blocks with basic programming constructs by including following:
a) If...then...Else, IF...ELSIF...ELSE... END IF       b) Case statement

using IF...THEN...ELSE, IF...ELSIF...ELSE...END IF, and a CASE statement:

-- PL/SQL Block with IF...THEN...ELSE and CASE statement

DECLARE
score NUMBER := 85; -- Change the score value as needed
result_message VARCHAR2(100); -- Declare a variable to store the result message
BEGIN
-- Using IF...THEN...ELSE
IF score >= 90 THEN
result_message := 'Excellent!';
ELSIF score >= 80 THEN
result_message := 'Good job!';
ELSIF score >= 70 THEN
result_message := 'Average.';
ELSE
result_message := 'Needs improvement.';
END IF; -- Display the result message
DBMS_OUTPUT.PUT_LINE('Result: ' || result_message);
CASE WHEN score >= 90 THEN -- Using CASE statement
result_message := 'Excellent!';
WHEN score >= 80 THEN
result_message := 'Good job!';
WHEN score >= 70 THEN
result_message := 'Average.';
ELSE result_message := 'Needs improvement.';
END CASE; -- Display the result message from the CASE statement
DBMS_OUTPUT.PUT_LINE('Result from CASE: ' || result_message);
END;
/



Q.4) Writing PL/SQL Blocks with basic programming constructs for following Iterative Structure: a.
While-loop Statements b. For-loop Statements

Using a While-Loop Statement:

-- PL/SQL Block with a WHILE-loop
DECLARE
counter NUMBER := 1;
BEGIN
WHILE counter <= 5 LOOP -- Using a WHILE loop to print numbers from 1 to 5
DBMS_OUTPUT.PUT_LINE('Counter: ' || counter);
counter := counter + 1;
END LOOP;
END;
/
In this PL/SQL block:
1. We declare a variable counter and initialize it to 1.
2. We use a WHILE loop to iterate as long as counter is less than or equal to 5.
3. Inside the loop, we print the value of counter using DBMS_OUTPUT.PUT_LINE.
4. We increment counter by 1 in each iteration.
Using a For-Loop Statement:
-- PL/SQL Block with a FOR-loop
DECLARE
BEGIN
FOR counter IN 1..5 LOOP -- Using a FOR loop to print numbers from 1 to 5
DBMS_OUTPUT.PUT_LINE('Counter: ' || counter);
END LOOP;
END;
/



Q.5) Writing PL/SQL Blocks with basic programming constructs by including a GOTO to jump out of
a loop and NULL as a statement inside IF.

-- PL/SQL Block with GOTO and NULL as a statement
DECLARE
counter NUMBER := 1;
BEGIN
<<my_loop>> -- Using a loop with a GOTO statement
LOOP
IF counter > 3 THEN -- Check if counter is greater than 3
GOTO exit_loop; -- Jump out of the loop using GOTO
END IF;
DBMS_OUTPUT.PUT_LINE('Counter: ' || counter); -- Display the current counter value
counter := counter + 1; -- Increment the counter
END LOOP
my_loop;
<<exit_loop>> -- Label to jump to when using GOTO
DBMS_OUTPUT.PUT_LINE('Loop exited.');
IF counter > 5 THEN -- Using NULL as a statement inside an IF condition
NULL; -- NULL can be used as a placeholder for no action
ELSE
DBMS_OUTPUT.PUT_LINE('Counter is not greater than 5.');
END IF;
END;
/



Q.6) Writing Procedures in PL/SQL Block
a. Create an empty procedure, replace a procedure and call procedure
b. Create a stored procedure and call it
c. Define procedure to insert data
d. A forward declaration of procedure


a. Create an Empty Procedure, Replace a Procedure, and Call a Procedure:

-- Create an empty procedure
CREATE OR REPLACE PROCEDURE empty_procedure AS
BEGIN
NULL; -- Placeholder, does nothing
END;
/
-- Replace the empty procedure with a new one
CREATE OR REPLACE PROCEDURE new_procedure AS
BEGIN
DBMS_OUTPUT.PUT_LINE('This is a new procedure.');
END;
/ -- Call the new procedure
BEGIN
new_procedure;
END;
/
In this example:
• We first create an empty procedure named empty_procedure.
• Then, we replace it with a new procedure named new_procedure that prints a message.
• Finally, we call the new_procedure from an anonymous PL/SQL block.

b. Create a Stored Procedure and Call It:
sqlCopy code
-- Create a stored procedure CREATE OR REPLACE PROCEDURE print_message AS BEGIN
DBMS_OUTPUT.PUT_LINE('Hello, world!'); END; / -- Call the stored procedure BEGIN
print_message; END; /
Here, we create a stored procedure named print_message that prints a simple message, and
then we call the procedure from an anonymous PL/SQL block.

c. Define a Procedure to Insert Data:
-- Create a table for demonstration
CREATE TABLE employees (emp_id NUMBER PRIMARY KEY, emp_name VARCHAR2(50) );
-- Create a procedure to insert data into the employees table
CREATE OR REPLACE PROCEDURE insert_employee(emp_id NUMBER, emp_name VARCHAR2)
AS
BEGIN
END; /
BEGIN
END;/
INSERT INTO employees (emp_id, emp_name)
VALUES (emp_id, emp_name);
COMMIT;
insert_employee(101, 'John Doe'); -- Call the procedure to insert data
insert_employee(102, 'Jane Smith');
In this example, we create a stored procedure named insert_employee that takes two
parameters (emp_id and emp_name) and inserts data into the employees table. We then call
the procedure twice to insert two employee records.

d. Forward Declaration of a Procedure:
In PL/SQL, you typically don't need forward declarations like you do in some other
programming languages. PL/SQL allows you to declare procedures and functions in any order
within a block. Here's an example:
sqlCopy code
-- Procedure declared after it's called BEGIN -- Call the procedure my_procedure; -- Declare the
procedure after calling it PROCEDURE my_procedure AS BEGIN DBMS_OUTPUT.PUT_LINE('This
is my procedure.'); END; END; /
In this example, we first call the my_procedure procedure before declaring it. PL/SQL allows
this order because it doesn't require forward declarations.


Q.7)Writing Functions in PL/SQL Block.
a. Define and call a function
b. Define and use function in select clause,
c. Call function in dbms_output.put_line
d. Recursive function
e. Count Employee from a function and return value back
f. Call function and store the return value to a variable

a. Define and Call a Function:

-- Define a simple function
CREATE OR REPLACE FUNCTION greet(name_in VARCHAR2)
RETURN VARCHAR2
IS
greeting VARCHAR2(100);
BEGIN
END;/
greeting := 'Hello, ' || name_in || '!';
RETURN greeting;
DECLARE
message VARCHAR2(100);
BEGIN
message := greet('John'); -- Call the function
DBMS_OUTPUT.PUT_LINE(message);
END; /
In this example:
• We define a function named greet that takes a name as input and returns a greeting
message.
• We call the greet function with the name 'John' and display the result using
DBMS_OUTPUT.PUT_LINE.

b. Define and Use Function in Select Clause:
-- Define a function to calculate the square of a number
CREATE OR REPLACE FUNCTION calculate_square(num NUMBER)
RETURN NUMBER
IS
BEGIN
RETURN num * num;
END; /
-- Use the function in a SELECT statement
SELECT employee_name, calculate_square(salary) AS square_salary FROM employees;
In this example:
• We define a function calculate_square that calculates the square of a number.
• We use the calculate_square function in a SELECT statement to calculate the square of
the salary column for each employee.

c. Call Function in DBMS_OUTPUT.PUT_LINE:
-- Define a function to concatenate two strings
CREATE OR REPLACE FUNCTION concat_strings(str1 VARCHAR2, str2 VARCHAR2)
RETURN VARCHAR2 IS
BEGIN
RETURN str1 || ' ' || str2;
END; / -- Call the function and display the result using DBMS_OUTPUT
BEGIN
DBMS_OUTPUT.PUT_LINE(concat_strings('John', 'Doe'));
END; /
In this example, we define a function concat_strings that concatenates two strings and then call
it within DBMS_OUTPUT.PUT_LINE to display the result.

d. Recursive Function:
PL/SQL allows recursive function calls. Here's a simple example of a recursive function to
calculate the factorial of a number:
-- Define a recursive function to calculate factorial
CREATE OR REPLACE FUNCTION factorial(num NUMBER) RETURN NUMBER
IS
BEGIN
IF num <= 1 THEN
RETURN 1;
END;/
ELSE
END IF;
RETURN num * factorial(num - 1);
DECLARE
result NUMBER;
BEGIN
END;/
result := factorial(5); -- Call the recursive function
DBMS_OUTPUT.PUT_LINE('Factorial of 5 is ' || result);
In this example, the factorial function calls itself recursively to calculate the factorial of a
number.

e. Count Employees from a Function and Return Value:
-- Define a function to count employees in a department
CREATE OR REPLACE FUNCTION count_employees(department_id NUMBER)
RETURN NUMBER
IS
employee_count NUMBER;
BEGIN
SELECT COUNT(*) INTO employee_count FROM employees
WHERE department_id = department_id;
RETURN employee_count;
END; / -- Call the function to count employees in department 101 DECLARE count NUMBER;
BEGIN
END;/
count := count_employees(101);
DBMS_OUTPUT.PUT_LINE('Number of employees in department 101: ' || count);
In this example, we define a function count_employees to count employees in a specified
department and return the count.

f. Call Function and Store the Return Value to a Variable:
-- Define a function to calculate the sum of two numbers
CREATE OR REPLACE FUNCTION calculate_sum(num1 NUMBER, num2 NUMBER)
RETURN NUMBER
IS
BEGIN
RETURN num1 + num2;
END; / -- Call the function and store the result in a variable
DECLARE
result NUMBER;
BEGIN
result := calculate_sum(10, 20);
DBMS_OUTPUT.PUT_LINE('The sum is: ' || result);
END;/


Q.8) Creating and working with Insert/Update/Delete Trigger using Before/After clause
1. Creating a BEFORE INSERT Trigger:

-- Creating a table for demonstration
CREATE TABLE employees ( emp_id NUMBER PRIMARY KEY, emp_name VARCHAR2(50),
emp_salary NUMBER );
-- Creating a BEFORE INSERT trigger
CREATE OR REPLACE TRIGGER before_insert_trigger
BEFORE INSERT ON employees FOR EACH ROW
BEGIN
-- You can modify the :NEW values before inserting
IF :NEW.emp_salary < 30000 THEN
:NEW.emp_salary := 30000; -- Set a minimum salary
END IF;
END; /
In this example:
• We create a table named employees with columns for employee ID, name, and salary.
• We create a BEFORE INSERT trigger named before_insert_trigger on the employees
table.
• Inside the trigger, we check if the salary being inserted is less than 30,000 and, if so, set
it to a minimum of 30,000 before the insertion takes place.

2. Creating an AFTER UPDATE Trigger:

-- Creating an AFTER UPDATE trigger
CREATE OR REPLACE TRIGGER after_update_trigger
AFTER UPDATE ON employees FOR EACH ROW BEGIN
-- Log the update action to another table
INSERT INTO audit_log (action, emp_id, old_salary, new_salary)
VALUES ('UPDATE', :OLD.emp_id, :OLD.emp_salary, :NEW.emp_salary);
END; /
In this example:
• We create an AFTER UPDATE trigger named after_update_trigger on the employees
table.
• Inside the trigger, we log the update action to an audit_log table, capturing the
employee ID, old salary, and new salary.

3. Creating a BEFORE DELETE Trigger:

-- Creating a BEFORE DELETE trigger
CREATE OR REPLACE TRIGGER before_delete_trigger BEFORE DELETE ON employees FOR EACH
ROW BEGIN
-- Prevent deletion of employees with a specific condition
IF :OLD.emp_id = 1 THEN
RAISE_APPLICATION_ERROR(-20001, 'Cannot delete employee with ID 1');
END IF;
END; /



Q.9) Write an Implicit and explicit cursor to complete the task.

Implicit Cursor Example:
Implicit cursors are automatically created and managed by the PL/SQL engine for SQL
statements inside PL/SQL blocks. Here's an example of an implicit cursor to retrieve and display
the names and salaries of employees with a salary greater than 50,000:
DECLARE -- Declare variables to hold employee data
emp_name employees.emp_name%TYPE;
emp_salary employees.emp_salary%TYPE;
BEGIN -- Implicit cursor to retrieve data
FOR emp_rec IN (SELECT emp_name, emp_salary FROM employees
WHERE emp_salary > 50000)
LOOP -- Assign values from the cursor to variables
emp_name := emp_rec.emp_name;
emp_salary := emp_rec.emp_salary;
DBMS_OUTPUT.PUT_LINE('Name: ' || emp_name || ', Salary: ' || emp_salary);
-- Display employee data
END LOOP;
END; /
In this example:
• We use an implicit cursor in the form of a FOR loop to retrieve data from the employees
table for employees with a salary greater than 50,000.
• Inside the loop, we assign values from the cursor to variables and then display the
employee data using DBMS_OUTPUT.PUT_LINE.
Explicit Cursor Example:
Explicit cursors are declared and managed explicitly by the developer. Here's an example of an
explicit cursor to achieve the same task of retrieving and displaying the names and salaries of
employees with a salary greater than 50,000:
DECLARE -- Declare variables to hold employee data
emp_name employees.emp_name%TYPE;
emp_salary employees.emp_salary%TYPE;
CURSOR emp_cursor IS SELECT emp_name, emp_salary FROM employees
WHERE emp_salary > 50000; -- Declare an explicit cursor
BEGIN -- Open the cursor
OPEN emp_cursor; -- Fetch and process data from the cursor
LOOP
FETCH emp_cursor INTO emp_name, emp_salary;
EXIT WHEN emp_cursor%NOTFOUND; -- Exit the loop when there is no more data
DBMS_OUTPUT.PUT_LINE('Name: ' || emp_name || ', Salary: ' || emp_salary);
-- Display employee data
END LOOP;
CLOSE emp_cursor; -- Close the cursor
END; /



Q.10)Create packages and use it in SQL black to complete the task

Let's create a simple package that contains a function to calculate the square of a number:

-- Create a package specification
CREATE OR REPLACE PACKAGE math_package AS
FUNCTION calculate_square(num NUMBER)
RETURN NUMBER;
END math_package;
Now, let's create the package body that defines the implementation of the function:
-- Create a package body
CREATE OR REPLACE PACKAGE BODY math_package AS
FUNCTION calculate_square(num NUMBER) RETURN NUMBER IS
BEGIN
RETURN num * num;
END calculate_square;
END math_package;
The package math_package contains one function, calculate_square, which calculates the
square of a number.
Now, let's use the package and the function in a PL/SQL block:
-- Using the math_package in a PL/SQL block
DECLARE
number_to_square NUMBER := 5;
result NUMBER;
BEGIN -- Call the function from the package
result := math_package.calculate_square(number_to_square); -- Display the result using
DBMS_OUTPUT DBMS_OUTPUT.PUT_LINE('The square of ' || number_to_square || ' is ' ||
result);
END;


Q.11) Write a SQL block to handle exception by writing:
a. Predefined Exceptions.
b. User-Defined Exceptions.
c. Redeclared Predefined Exceptions

a. Handling Predefined Exceptions:
DECLARE
v_num1 NUMBER := 10;
v_num2 NUMBER := 0;
v_result NUMBER;
BEGIN -- Attempt to divide by zero
v_result := v_num1 / v_num2
-- This line will not be executed due to the exception
DBMS_OUTPUT.PUT_LINE('Result: ' || v_result); ;
EXCEPTION WHEN ZERO_DIVIDE THEN -- Handle the predefined ZERO_DIVIDE exception
DBMS_OUTPUT.PUT_LINE('Division by zero is not allowed.');
END;
In this example, we attempt to divide v_num1 by zero (v_num2). Since division by zero is not
allowed, a predefined exception called ZERO_DIVIDE is raised. We catch this exception in the
EXCEPTION section and handle it by displaying a custom error message.

b. Handling User-Defined Exceptions:
DECLARE
v_num NUMBER := -5;
NegativeNumberException EXCEPTION; -- User-defined exception
PRAGMA EXCEPTION_INIT(NegativeNumberException, -20001);
BEGIN
IF v_num < 0 THEN -- Raise the user-defined exception
RAISE NegativeNumberException;
END IF;
-- This line will not be executed if v_num is negative
DBMS_OUTPUT.PUT_LINE('Number is positive.');
EXCEPTION WHEN NegativeNumberException THEN
-- Handle the user-defined exception
DBMS_OUTPUT.PUT_LINE('Negative numbers are not allowed.');
END;
In this example, we define a user-defined exception called NegativeNumberException and
associate it with Oracle error code -20001. If v_num is negative, we explicitly raise this
exception. We then catch and handle the user-defined exception in the EXCEPTION section.

c. Handling Redeclared Predefined Exceptions:
DECLARE
v_num NUMBER := 10;
v_result NUMBER;
BEGIN -- Attempt to convert a non-numeric value to a number
v_result := TO_NUMBER('abc'); -- This line will not be executed due to the exception
DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
EXCEPTION WHEN VALUE_ERROR THEN
-- Redeclare and handle the predefined VALUE_ERROR exception
DBMS_OUTPUT.PUT_LINE('Invalid value for conversion.');
END;



Q12) Create nested tables and work with nested tables.

Let's create a table with a nested table column, insert data into it, and query the nested table
column.

-- Create a nested table type
CREATE OR REPLACE phone_numbers TYPE AS TABLE OF VARCHAR2(20);
-- Create a table with a nested table column
CREATE TABLE employees (emp_id NUMBER PRIMARY KEY, emp_name VARCHAR2(50),
emp_phones phone_numbers ); -- Insert data into the table
INSERT INTO employees (emp_id, emp_name, emp_phones)
VALUES (1, 'John Doe', phone_numbers('555-1234', '555-5678'));
INSERT INTO employees (emp_id, emp_name, emp_phones)
VALUES (2, 'Jane Smith', phone_numbers('555-9876')); -- Query the nested table column
SELECT emp_id, emp_name, COLUMN_VALUE AS
phone_number FROM employees, TABLE(emp_phones);
